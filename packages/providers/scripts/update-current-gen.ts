#!/usr/bin/env bun
/**
 * Updates current-gen.ts with latest generation models per provider.
 * Fetches from models.dev API and uses haiku to analyze with release dates.
 *
 * Usage: bun run --cwd packages/providers scripts/update-current-gen.ts
 */

import { generateText } from "ai"
import { createAmazonBedrock } from "@ai-sdk/amazon-bedrock"
import { fromIni } from "@aws-sdk/credential-providers"
import * as fs from "node:fs"
import * as path from "node:path"

const bedrock = createAmazonBedrock({
  region: "us-east-1",
  credentialProvider: fromIni(),
})

const HAIKU_MODEL = "us.anthropic.claude-3-5-haiku-20241022-v1:0"

// Providers we support
const SUPPORTED_PROVIDERS = ["anthropic", "amazon-bedrock", "openai", "google", "mistral"]

// Map models.dev provider IDs to our IDs
const PROVIDER_MAP: Record<string, string> = {
  anthropic: "anthropic",
  "amazon-bedrock": "bedrock",
  openai: "openai",
  google: "google",
  mistral: "mistral",
}

interface ModelsDevModel {
  id: string
  name: string
  release_date?: string
  tool_call?: boolean
  reasoning?: boolean
}

interface ModelsDevProvider {
  id: string
  name: string
  models: Record<string, ModelsDevModel>
}

type ModelsDevApi = Record<string, ModelsDevProvider>

const SYSTEM_PROMPT = `You are a model classification assistant. Given a list of AI models with their provider, name, and release date, identify the "current generation" models for each provider.

For each provider:
1. Find the LATEST version number based on release_date
2. Include ALL variants/sizes of that version (opus, sonnet, haiku, mini, flash, pro, codex, etc.)
3. Exclude older versions entirely
4. Prefer dated versions over "latest" aliases
5. MUST include models from ALL providers: anthropic, bedrock, openai, google, mistral

Examples - include the ENTIRE family of the latest version:
- anthropic 4.5: claude-opus-4-5-*, claude-sonnet-4-5-*, claude-haiku-4-5-*
- bedrock: ONLY Claude models (anthropic.claude-*-4-5-*), no llama/qwen/gemma/etc
- openai 5.2: gpt-5.2, gpt-5.2-mini, gpt-5.2-codex, etc. (all 5.2 variants)
- google gemini-3: gemini-3-flash-*, gemini-3-pro-*, etc. (all gemini-3 variants)
- mistral: mistral-large-2512, devstral-*, codestral-*, etc. (all latest mistral variants)

Return ONLY a JSON array of model IDs. Include ALL variants of the latest version for each provider.`

async function main() {
  // Fetch from models.dev
  console.log("Fetching from models.dev...")
  const response = await fetch("https://models.dev/api.json")
  if (!response.ok) {
    throw new Error(`API error: ${response.status}`)
  }
  const api = (await response.json()) as ModelsDevApi

  // Extract models from supported providers
  const modelList: Array<{
    id: string
    name: string
    provider: string
    release_date: string | undefined
  }> = []

  for (const providerId of SUPPORTED_PROVIDERS) {
    const providerData = api[providerId]
    if (!providerData) continue

    const ourProviderId = PROVIDER_MAP[providerId]
    if (!ourProviderId) continue

    for (const [modelId, model] of Object.entries(providerData.models)) {
      // Skip non-chat models (no tool_call usually means embedding/audio)
      if (model.tool_call === false && model.reasoning === false) continue

      modelList.push({
        id: `${ourProviderId}/${modelId}`,
        name: model.name,
        provider: ourProviderId,
        release_date: model.release_date,
      })
    }
  }

  console.log("Found", modelList.length, "models, analyzing with haiku...")

  const result = await generateText({
    model: bedrock(HAIKU_MODEL),
    system: SYSTEM_PROMPT,
    prompt: JSON.stringify(modelList, null, 2),
    maxOutputTokens: 2000,
  })

  // Parse the response - extract JSON array from response
  let currentGenIds: string[]
  try {
    // Try direct parse first
    currentGenIds = JSON.parse(result.text)
  } catch {
    // Extract JSON array from markdown code block or surrounding text
    const match = result.text.match(/\[[\s\S]*?\]/)
    if (!match) {
      console.error("Failed to find JSON array in response:", result.text)
      process.exit(1)
    }
    currentGenIds = JSON.parse(match[0])
  }

  if (!Array.isArray(currentGenIds)) {
    console.error("Expected array, got:", currentGenIds)
    process.exit(1)
  }

  console.log("Current gen models:", currentGenIds.length)

  // Generate the TS file
  const output = `// Auto-generated by packages/providers/scripts/update-current-gen.ts
// Last updated: ${new Date().toISOString()}

import type { ModelId } from "./model.js"

/**
 * Current generation model IDs per provider.
 * These are the latest/flagship models that should be shown by default.
 */
export const CURRENT_GEN_MODEL_IDS: readonly ModelId[] = [
${currentGenIds.map((id) => `  "${id}" as ModelId,`).join("\n")}
]
`

  const outPath = path.resolve(import.meta.dir, "../../core/src/current-gen.ts")
  fs.writeFileSync(outPath, output)
  console.log("Wrote", outPath)

  // Also log what was selected with release dates
  console.log("\nSelected models:")
  for (const id of currentGenIds) {
    const model = modelList.find((m) => m.id === id)
    console.log(`  ${id} - ${model?.name ?? "?"} (${model?.release_date ?? "?"})`)
  }
}

main().catch((e) => {
  console.error(e)
  process.exit(1)
})
